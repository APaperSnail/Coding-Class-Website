<html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.js"></script>
    <script>

        const CANVAS_WIDTH  = 900;
        const CANVAS_HEIGHT = 900;

        const SPEED_FACTOR = 0.05;        // affects the speed
        const ACCELLERATION_FACTOR = 0.1; // affects the acceleleration
        const SLOWDOWN = 0.50;

        //let colors = ["red","yellow","green"];
        let colors = [];
        for(let i=0; i<360; i+=7) {
            let h = i;
            let s = 100;
            let l = 50;
            let hsl = 'hsl(' + h + ',' + s + '%,' + l + '%)';
            let rgb = hslToRgb(h, s, l);
            colors.push(rgb);
        }

        function hslToRgb(h, s, l){
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;
            if(s == 0){
                r = g = b = l; // achromatic
            }else{
                let hue2rgb = function hue2rgb(p, q, t){
                    if(t < 0) t += 1;
                    if(t > 1) t -= 1;
                    if(t < 1/6) return p + (q - p) * 6 * t;
                    if(t < 1/2) return q;
                    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return 'rgb(' + Math.round(r * 255) + ',' + Math.round(g * 255) + ',' + Math.round(b * 255) + ')';
        }
        
        let segNum = 100,
            segLength = 8;

        let segments = [];
        for (let i = 0; i < segNum; i++) {
            segments[i] = {
                i: i,
                x: CANVAS_HEIGHT / 2, // start the segments in the middle
                y: CANVAS_WIDTH / 2, // start the segments in the middle
                size: 5, // will be used to set stroke width
                color: "white",
                dx: 0, // speed on the x-axis (the rate of change of x)
                dy: 0, // speed on the y-axis (the rate of change of y)
                ddx: 0, // accelleration on the x-axis (the rate of change of dx)
                ddy: 0, // accelleration on the y-axis (the rate of change of dy)
                angle: 0 // the angle of the segment (not necessarily the angle of movement)
            }
        }
        
        function setup() {
            createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        let prevMouseX = 0;
        let prevMouseY = 0;
        function draw() {
            background(0);

            // if the mouse moved, then drag the segments
            if (prevMouseX != mouseX || prevMouseY != mouseY) {
                dragSegment(0, mouseX, mouseY);
                for (let i = 0; i < segments.length - 1; i++) {
                    dragSegment(i + 1, segments[i].x, segments[i].y);
                }
            } else {
                // the mouse did not move so let the speed and accelleration die down
                for (let i = 0; i < segments.length - 1; i++) {
                    segments[i].dx + segments[i].ddx;
                    segments[i].dy + segments[i].ddx;
                    segments[i].ddx *= SLOWDOWN;
                    segments[i].ddy *= SLOWDOWN;

                    segments[i].x += segments[i].dx;
                    segments[i].y += segments[i].dy;
                    
                    // check if the segment is at the edge of the canvas and if so, reverse its direction
                    if (segments[i].x <= 0 || segments[i].x >= CANVAS_WIDTH) {
                        segments[i].dx = -segments[i].dx * 0.5;
                        segments[i].ddx = -segments[i].ddx * 0.5;
                        segments[i].angle = Math.PI - segments[i].angle;
                    }
                    if (segments[i].y <= 0 || segments[i].y >= CANVAS_HEIGHT) {
                        segments[i].dy = -segments[i].dy * 0.5;
                        segments[i].ddy = -segments[i].ddy * 0.5;
                        segments[i].angle = Math.PI - segments[i].angle;
                    }

                    segment(segments[i]);
                }
            }
            prevMouseX = mouseX;
            prevMouseY = mouseY;
        }

        function dragSegment(i, xin, yin) {
            // how much movement is there in the x and y axis
            const dx = xin - segments[i].x;
            const dy = yin - segments[i].y;

            // it moved, and therefore use the chain behavior
            const angle = atan2(dy, dx);
            x[i] = xin - cos(angle) * segLength;
            y[i] = yin - sin(angle) * segLength;
            stroke(colors[i % colors.length])
            strokeWeight(i / 3 + 5)
            segment(x[i], y[i], angle);
        }

        function segment(s) {
            var dx = s.dx;
            var dy = s.dy;
            
            if (dx < 0) {
                dx = -dx;
            };


            if (dy < 0) {
                dy = -dy;
            };

            s.size = 10 / Math.max(dx + dy, 1) * 2;//(Math.sin((s.i + frameCount) / 5) * 10 + 12)  s.SPEED_FACTOR;

            stroke(s.color);
            push();
            strokeWeight(s.size);
            translate(s.x, s.y);
            rotate(s.angle);
            line(0, 0, segLength, 0);
            
            // get a random number between -25 and 25
            let randomNum = Math.floor(Math.random() * 11) - 10;
            
            strokeWeight(s.size / 2);
            line(0, 25, segLength, 25);
            line(0, -25, segLength, -25);
            pop();
        }

    </script>
</head>

<body>
    <main>
    </main>
</body>

</html>